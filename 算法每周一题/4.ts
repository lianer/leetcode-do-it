/*
本周题目: 跳跃游戏2
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
找到最短路径可以到达最后一个位置。

示例:
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

说明:
假设你总是可以到达数组的最后一个位置。

提示： 考察点还是贪心算法，如何在时间复杂度O(n) 和空间复杂度 O(1)下完成
*/

/*
解题思路：
把每次跳跃视为一个范围区间，然后在这个范围区间内去计算最远可跳到的位置

假设有：[2, 3, 1, 1, 4]
  1. 第一次跳跃，范围区间是 0~2
  2. 第二次跳跃，在范围区间内计算最远可跳到的位置，结果是 4，已经到达最后一个位置了，总共跳了 2 次

假设有：[2, 1, 2, 1, 2, 3]
  1. 第一次跳跃，范围区间是 0~2
  2. 第二次跳跃，在范围区间内计算最远可跳到的位置，结果是 4，第二次跳跃的范围区间是 3~4
  3. 第三次跳跃，在范围区间内计算最远可跳到的位置，结果是 6，已经到达最后一个位置了，总共跳了 3 次
*/

/**
 * @param {number[]} nums
 * @return {number}
 */
const jump = function(nums: number[]) {
  let farthest = 0;
  let steps = 0;
  let end = 0;

  for (let i = 0; i < nums.length - 1; i++) {
    farthest = Math.max(i + nums[i], farthest);
    if (i === end) {
      if (farthest <= end) {
        return -1;
      }
      steps++;
      end = farthest;
    }
  }

  return steps;
};

console.log(jump([2, 3, 1, 1, 4]), 2);
console.log(jump([1, 1, 1, 1, 0]), 4);
console.log(jump([4, 1, 1, 1, 0]), 1);
console.log(jump([0, 1, 1, 1, 0]), -1);
console.log(jump([1, 1, 1, 0, 0]), -1);
console.log(jump([7, 0, 9, 6, 9, 6, 1, 7, 9, 0, 1, 2, 9, 0, 3]), 2);

export { jump };
